/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: GPIO Toggle Example
*              for ModusToolbox.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"

#include "cy_retarget_io.h"

#include "SEGGER_RTT.h"


#define MY_ENABLED 1
#define MY_DISABLED 0
#define uCPROBE_GUI_OSCILLOSCOPE MY_DISABLED // ENABLED
#if(uCPROBE_GUI_OSCILLOSCOPE == MY_ENABLED)
#include "ProbeScope/probe_scope.h"
#endif

#include "uart.h"
#include "motor.h"
#include "ebike_app.h"
#include "eeprom.h"


/* Define macro to enable/disable printing of debug messages */    // for debugging
#define ENABLE_XMC_DEBUG_VADC_PRINT              (0)
#define SEND_FRAME_100MS                    (0) // 1 = get the frame from the display (currently do not print them)
#define RECEIVE_FRAME                       (0) // 1 = send frame to display
#define ENABLE_DEBUG_HALL_PATTERN           (1)

/*******************************************************************************
* Macros
*******************************************************************************/

/* SysTick timer frequency in Hz  */
#define TICKS_PER_SECOND            1000

/* USER LED toggle period in milliseconds */    // for debugging
#define USER_LED_TOGGLE_PERIOD_MS   5000
#define USER_SEND_FRAME 100 // msec when ticks per sec = 1000

/*******************************************************************************
* Global Variables
*******************************************************************************/

/* Variable for keeping track of time */
volatile uint32_t system_ticks = 0;
uint32_t loop_25ms_ticks = 0;  
uint32_t start = 0 ; // mainly for debugging ; allow to print some variable every e.g. 5 sec

// for debugging only at the beginning
uint32_t count = 0;
uint32_t speed = 0; 
uint32_t pas_1 = 0;
uint32_t uart_rx = 0;
uint32_t brake = 0;
uint32_t unknown = 0;
//Used to store some data from interrupt and print in main loop at regular interval with
//               print_each_sec(uint32_t index, uint32_t value, uint32_t interval_ms)
uint32_t debug_values[20] ; // 
uint32_t debug_values_copy[20] = {0};
    

/* Declaration of array to store the message to be transmitted */
const uint8_t message[] = "Hello world!!\r\n";
const uint8_t clear_screen[] = "Hello from setup\r\n";


extern uint8_t ui8_received_package_flag ;
extern uint8_t ui8_tx_buffer[];

// for debugging
uint16_t phase_U_timer = 0; // just to debug - see if ccu8 is running
uint16_t phase_V_timer = 0; // just to debug - see if ccu8 is running
uint16_t phase_W_timer = 0; // just to debug - see if ccu8 is running
uint16_t phase_U_comp = 0; // just to debug - see if ccu8 is running
uint16_t phase_V_comp = 0; // just to debug - see if ccu8 is running
uint16_t phase_W_comp = 0; // just to debug - see if ccu8 is running

extern volatile uint32_t hall_print_pos ; 
extern volatile uint32_t hall_print_angle ;
extern volatile bool new_hall ;   
extern volatile uint32_t hall_print_pos2; // current hall pattern (after a sampling delay)
extern volatile uint32_t hall_print_interval ; // interval between 2 correct hall transitions
extern volatile uint32_t posif_SR0; 
extern volatile uint32_t posif_SR1;
extern volatile uint32_t posif_print_current_pattern ;

extern volatile uint32_t hall_pattern_irq;                   // current hall pattern
extern volatile uint16_t hall_pattern_change_ticks_irq; // ticks from ccu4 slice 2 for last pattern change
extern volatile uint16_t ui16_a ;
extern volatile uint16_t ui16_b ;
extern volatile uint16_t ui16_c ;
extern uint8_t ui8_svm_table_index_print  ; 
extern uint16_t ui16_temp_print  ;
extern uint16_t ui16_a_print ;
extern uint16_t ui16_new_angle_print; 
uint16_t ccu4_S2_timer ; 
extern uint16_t current_average ;
extern uint16_t hall_pattern_intervals[8];

extern volatile uint16_t debug_time_ccu8_irq0; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )
extern volatile uint16_t debug_time_ccu8_irq1; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )
extern volatile uint16_t debug_time_ccu8_irq1b; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )
extern volatile uint16_t debug_time_ccu8_irq1c; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )
extern volatile uint16_t debug_time_ccu8_irq1d; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )
extern volatile uint16_t debug_time_ccu8_irq1e; // to debug time in irq0 CCU8 (should be less than 25usec; 1 = 4 usec )


/*******************************************************************************
* Function Name: SysTick_Handler
********************************************************************************
* Summary:
* This is the interrupt handler function for the SysTick timer interrupt.
* It counts the time elapsed in milliseconds since the timer started. 
*******************************************************************************/
void SysTick_Handler(void)
{
    system_ticks++;
}

/*******************************************************************************
* Function Name: sys_now
********************************************************************************
* Summary:
* Returns the current time in milliseconds.
*
* Parameters:
*  none
*
* Return:
*  the current time in milliseconds
*
*******************************************************************************/
//__STATIC_INLINE uint32_t sys_now(void)
//{
//    return system_ticks;
//}

#define CHANNEL_NUMBER_PIN_2_2              (7U) // Torque
#define CHANNEL_NUMBER_PIN_2_3              (5U) // unknown
#define CHANNEL_NUMBER_PIN_2_4              (6U) // Battery
#define CHANNEL_NUMBER_PIN_2_5              (7U) // Throttle
#define CHANNEL_NUMBER_PIN_2_6              (0U) // Vcc
#define CHANNEL_NUMBER_PIN_2_7              (1U) // Unknown

#define CHANNEL_NUMBER_PIN_2_8              (1U) // Current 1 if group 0
#define CHANNEL_NUMBER_PIN_2_9              (2U) // Current U if group 0
#define CHANNEL_NUMBER_PIN_2_10             (3U) // Current v if group 0
#define CHANNEL_NUMBER_PIN_2_11             (4U) // Current W if group 0


// ************* declaration **********
void print_vadc(void);
void print_system_state();
void print_hall_pattern_debug();
void print_hall_pattern_debug2();

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function. It sets up a timer to trigger a 
* periodic interrupt. The main while loop checks for the elapsed time
* and toggles an LED at 1Hz to create an LED blinky. 
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/

int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    #if(uCPROBE_GUI_OSCILLOSCOPE == MY_ENABLED)
    ProbeScope_Init(20000);
    #endif
    // init segger to allow kind of printf
    SEGGER_RTT_Init ();     
    SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_TRIM);
    SEGGER_RTT_WriteString(0, RTT_CTRL_CLEAR); // clear the RTT terminal

    // set the PWM in such a way that PWM are set to passive levels when processor is halted for debugging (safety)
    XMC_CCU8_SetSuspendMode(ccu8_0_HW, XMC_CCU8_SUSPEND_MODE_SAFE_STOP);

    /* Initialize printf retarget */
    cy_retarget_io_init(CYBSP_DEBUG_UART_HW);

    /* System timer configuration */
    SysTick_Config(SystemCoreClock / TICKS_PER_SECOND);
 
    // CCU8 slice 3 (IRQ at mid point) generates a SR3 when period match and this trigger a VADC group 0 for queue
    // CCU8 slice 2 (PWM) is configured in device generator to generate a sr2 when ONE match
    //  but device configurator does not allow to setup a second trigger for vadc queue conversion
    // some setup has to be done manually in the group1 queue
     // we have to connect sr2 to vadc group1 queue, to activate trigering and to disable gating.
    
    
    #define GxREQTRI 8 // SR2 from CCU8 slice 2
    const XMC_VADC_QUEUE_CONFIG_t vadc_0_group_1_queue_config2 = {
        .conv_start_mode = (uint32_t) XMC_VADC_STARTMODE_WFS,
        .req_src_priority = (uint32_t) XMC_VADC_GROUP_RS_PRIORITY_2,
        .src_specific_result_reg = (uint32_t) 0,
        .trigger_signal = (uint32_t) GxREQTRI,
        .trigger_edge = (uint32_t) XMC_VADC_TRIGGER_EDGE_RISING,
        .gate_signal = (uint32_t) 0X01, //DISCARD_VADC_GATING
        .timer_mode = (uint32_t) false,
        .external_trigger = (uint32_t) true,
    };
    XMC_VADC_GROUP_QueueSetGatingMode(vadc_0_group_1_HW, (XMC_VADC_GATEMODE_t) XMC_VADC_GATEMODE_IGNORE);
    XMC_VADC_GROUP_QueueInit(vadc_0_group_1_HW, &vadc_0_group_1_queue_config2);
    

    /*Generate a load event to start background request source continuous conversion*/
    XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);

    // to test : this could be replaced by an interrupt on CCU4 slice 1 SR0 ( capture done)
    //NVIC_SetPriority(POSIF0_0_IRQn, 1U); //Testing with SR 0 when POSIF detect a valid transition (for debug)
	//NVIC_EnableIRQ(POSIF0_0_IRQn);
    
    // use CCU4 SR0 (slice 1 external event from POSIT) to say that a correct event occured
    //NVIC_SetPriority(CCU40_0_IRQn, 1U); //Testing with SR 0 when POSIF detect a valid transition (for debug)
	//NVIC_EnableIRQ(CCU40_0_IRQn);
    NVIC_SetPriority(CCU40_1_IRQn, 0U); //capture hall pattern and slice 2 time when a hall change occurs
	NVIC_EnableIRQ(CCU40_1_IRQn);
    

    /* CCU80_0_IRQn and CCU80_1_IRQn. slice 3 interrupt on counting up and down. at 19 khz to manage rotating flux*/
	NVIC_SetPriority(CCU80_0_IRQn, 1U);
	NVIC_EnableIRQ(CCU80_0_IRQn);
    NVIC_SetPriority(CCU80_1_IRQn, 1U);
	NVIC_EnableIRQ(CCU80_1_IRQn);

    // set initial position of hall sensor and first next expected one in shadow and load immediately in real register
    posif_init_position();
    XMC_POSIF_Start(HALL_POSIF_HW);
    
    /* Enable Global Start Control CCU80  in a synchronized way*/
    XMC_SCU_SetCcuTriggerHigh(SCU_GENERAL_CCUCON_GSC80_Msk);
    uint32_t retry_counter = 10;
    while ((!XMC_CCU8_SLICE_IsTimerRunning(PHASE_U_TIMER_HW)) && (retry_counter > 0)){
        XMC_SCU_SetCcuTriggerHigh(SCU_GENERAL_CCUCON_GSC80_Msk);
        //SEGGER_RTT_printf(0, "Retry CCU8 start; still %u try\r\n", retry_counter);
    }


    // todo : change when eeprom is coded properly add some initialisation (e.g. m_configuration_init() and ebike_app.init)
    m_configuration_init();
    
    // add some initialisation in ebike_app.init
    #if (AUTOMATIC_ROTATION != 1) // is not done when we are just testing slow motion to detect hall pattern
    ebike_app_init();
    #endif
    start = system_ticks;

    #if (SEND_FRAME_100MS)   // for debugging
    uint32_t send_frame_ticks = system_ticks;
    #endif

    
    /*
    // to test the performance of the divider of XMC13
    uint32_t numerator = 1234567;
    uint32_t denomminator = 1234;
    uint32_t div_result;
    uint16_t start = XMC_CCU4_SLICE_GetTimerValue(RUNNING_250KH_TIMER_HW);
    for (uint32_t i = 100; i>0; i--){
            XMC_MATH_DIV_UnsignedDivNB(numerator, denomminator)	;
            div_result = XMC_MATH_DIV_GetUnsignedDivResult();
    }
    uint16_t end = XMC_CCU4_SLICE_GetTimerValue(RUNNING_250KH_TIMER_HW);
    printf("delay for 100 division = %ld usec  result is %ld\r\n", (uint32_t) (end - start) * 4, div_result);
    */
    // for debugging try to start once the VADC group trigger queue 
    //XMC_VADC_GROUP_QueueTriggerConversion	( vadc_0_group_0_HW);

    //NVIC_SetPriority(POSIF0_0_IRQn, 0U); // this is just to have a link to the definition of the interrupt number

    
//***************************** while ************************************
    while (1) // main loop
    {     
        #if (RECEIVE_FRAME) // read uart and process when a frame is received
        while ( XMC_USIC_CH_RXFIFO_GetLevel(CYBSP_DEBUG_UART_HW) ){
            fillRxBuffer();
        }
        if (ui8_received_package_flag){
            processRxBuffer();
        }
        #endif
        
        /* once every X sec  */
        if ((system_ticks - start) > USER_LED_TOGGLE_PERIOD_MS) {
            start = system_ticks;
            count++; // increase count (to be checked with debug tool)
                        // toggle output (light on P1.5)
            XMC_GPIO_ToggleOutput(OUT_LIGHT_PORT,OUT_LIGHT_PIN); // toggle the output
            #if (uCPROBE_GUI_OSCILLOSCOPE == MY_ENABLED)
            ProbeScope_Sampling(); // this should be moved e.g. in a interrupt that run faster
            #endif
            // send Hello
            /*
            for (index = 0; index < sizeof(message) - 1; index++)
            {
                // Send a message via UART periodically 
                XMC_UART_CH_Transmit(CYBSP_DEBUG_UART_HW, message[index]);
            }
            */
            #if (ENABLE_XMC_DEBUG_VADC_PRINT == 1)
                print_vadc();  
            #endif
        }
        // once evey 100 msec send a dummy frame to display for debug
        #if (SEND_FRAME_100MS)
        if ((system_ticks- send_frame_ticks) > USER_SEND_FRAME) { // send a frame every 100 msec
            send_frame_ticks = system_ticks;
            fillTxBuffer();
            // send the full package to UART
            for(uint8_t i = 0; i < 9; i++)
            {
                XMC_UART_CH_Transmit(CYBSP_DEBUG_UART_HW , ui8_tx_buffer[i]);
            }    
        }
        #endif
        // for debug
        
        if (new_hall) {
            ccu4_S2_timer = XMC_CCU4_SLICE_GetTimerValue(RUNNING_250KH_TIMER_HW);
            //SEGGER_RTT_printf(0,"angle= %u pins= %u a=%u b=%u c=%u tim=%u\r\n ",
            //    (uint32_t) ui16_new_angle_print , (uint32_t) hall_print_pos , (uint32_t) ui16_a , (uint32_t)ui16_b , (uint32_t)ui16_c ,
            //     (uint32_t)ccu4_S2_timer);
            printf("angle= %u pins= %u a=%u b=%u c=%u tim=%u\r\n ",
                (uint32_t) ui16_new_angle_print , (uint32_t) hall_print_pos , (uint32_t) ui16_a , (uint32_t)ui16_b , (uint32_t)ui16_c ,
                 (uint32_t)ccu4_S2_timer);
            new_hall = false;
        }
        
       // to be activated for real production
       // Here we should call a funtion every 25 msec (based on systick or on an interrupt based on a CCU4 timer)
        #if (AUTOMATIC_ROTATION != 1)
        if ((system_ticks - loop_25ms_ticks) > 25) { 
            loop_25ms_ticks = system_ticks;
            ebike_app_controller();  // this performs some checks and update some variable every 25 msec
        }
        #endif
        //to debug print any error
       if (ui8_system_state) { // print a message when there is an error detected
            print_system_state();
       }
       #if (ENABLE_DEBUG_HALL_PATTERN == 1)
       print_hall_pattern_debug();
       //print_hall_pattern_debug2();
       #endif
       
       
    } // end while main loop
}

void print_vadc(void) {
    uint32_t vadc22 = 0;
    uint32_t vadc23 = 0;
    uint32_t vadc24 = 0;
    uint32_t vadc25 = 0;
    uint32_t vadc26 = 0;
    uint32_t vadc27 = 0;
    uint32_t vadc28 = 0;
    uint32_t vadc29 = 0;
    uint32_t vadc210 = 0;
    uint32_t vadc211 = 0;

    uint32_t vadc28bis = 0;
    uint32_t vadc29bis = 0;
    uint32_t vadc210bis = 0;
    uint32_t vadc211bis = 0;

    vadc22 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 2 ); // torque
    vadc23 = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 3 ); // unknow
    vadc24 = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 4 ); // battery
    vadc25 = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 5 ); // throttle
    vadc26 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 6 ); // Vcc
    vadc27 = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 7 ); // unknow
    vadc28 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 8 ); // current
    vadc29 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 9 ); // current U
    vadc210 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 10 ); // current V
    vadc211 = XMC_VADC_GROUP_GetResult(vadc_0_group_0_HW , 11 ); // current W
    
    vadc28bis = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 12 ); // current
    vadc29bis = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 13 ); // current U
    vadc210bis = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 14 ); // current V
    vadc211bis = XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 15 ); // current W
/* Prints the result in UART Terminal */
    printf("Torque= %lx \r\n", vadc22);
    //printf("2.3= %lx \r\n", vadc23);
    printf("Batt= %lx \r\n", vadc24);
    printf("Throttle= %lx \r\n", vadc25);
    //printf("2.6= %lx \r\n", vadc26);
    //printf("2.7= %lx \r\n", vadc27);
    printf("Current= %lx \r\n", vadc28);
    //printf("2.9= %lx \r\n", vadc29);
    //printf("2.10= %lx \r\n", vadc210);
    //printf("2.11= %lx \r\n", vadc211);
    
    printf("Cur.bis= %lx \r\n", vadc28bis);
    //printf("2.9bis= %lx \r\n", vadc29bis);
    //printf("2.10bis= %lx \r\n", vadc210bis);
    //printf("2.11bis= %lx \r\n", vadc211bis);
}

void print_system_state(){
    switch (ui8_system_state) {
        case 1: 
            printf("Error : overvoltage\r\n");
            break;
        case 2: 
            printf("Error : torque_sensor\r\n");
            break;
        case 3: 
            printf("Error : cadence_sensor\r\n");
            break;
        case 4: 
            printf("Error : motor_blocked\n");
            break;
        case 5: 
            printf("Error : throttle\r\n");
            break;
        case 6: 
            printf("Error : overtemperature\r\n");
            break;
        case 7: 
            printf("Error : battery_overcurrent\r\n");
            break;
        case 8: 
            printf("Error : speed_sensor\r\n");
            break;
        case 9: 
            printf("Error : motor_check\r\n");
            break;
             
    }
}    


void print_hall_pattern_debug(){
    if (take_action(0, 250)){ // every 500ms
        debug_values_copy[0] = debug_values[0] ; // ui8_svm_table_index
        debug_values_copy[1] = debug_values[1] ; // ui8_g_duty_cycle;
        debug_values_copy[2] = debug_values[2] ; // ui8_controller_adc_battery_current_target;
        debug_values_copy[3] = debug_values[3] ; // ui8_adc_battery_current_filtered;
        debug_values_copy[4] = debug_values[4] ; // ui8_motor_commutation_type;
        debug_values_copy[5] = debug_values[5] ; // ui8_interpolation_angle ;
        debug_values_copy[6] = debug_values[6] ; // enlapsed_time tick;
        debug_values_copy[7] = debug_values[7] ; // compensated_enlapsed_time;
        debug_values_copy[8] = debug_values[8] ; // ui16_hall_counter_total; 
        debug_values_copy[9] = debug_values[9] ; // hall_pattern_error_counter;
        debug_values_copy[10] = debug_values[10] ; // hall_pattern_valid_counter;
        debug_values_copy[11] = debug_values[11] ;// ui8_controller_duty_cycle_target;
        debug_values_copy[13]  = debug_values[13] ; //calibrated_offset_angle;
        uint32_t current_adc = (uint32_t) (XMC_VADC_GROUP_GetResult(vadc_0_group_1_HW , 12 ) & 0xFFFF); // current adc
        // current_average (calculated based on the 2 VADC on pin 2.8) for the same value of hall debug offset 
        // 6 ticks intervals between hall patern changes
        SEGGER_RTT_WriteString(0, "SEGGER Real-Time-Terminal Sample\r\n\r\n");
        printf("idx=%u dc=%u ct=%u cf=%u cty=%u ia=%u et=%u ct=%0u hct=%u hpe=%u hpv=%u dct=%u doa=%u cadc=%u cavg=%u, 1=%u 2=%u 3=%u 4=%u  5=%u  6=%u\r\n",
            debug_values_copy[0], debug_values_copy[1],debug_values_copy[2],
            debug_values_copy[3], debug_values_copy[4] , debug_values_copy[5],
            debug_values_copy[6], debug_values_copy[7], debug_values_copy[8],
            debug_values_copy[9], debug_values_copy[10] ,debug_values_copy[11] , debug_values_copy[13] , current_adc, current_average,
            hall_pattern_intervals[1],hall_pattern_intervals[2],hall_pattern_intervals[3],
            hall_pattern_intervals[4],hall_pattern_intervals[5],hall_pattern_intervals[6] );
        
        /*
        SEGGER_RTT_printf(0, "idx=%-3u dc=%-3u ct=%-4u cf=%-4u cty=%-4u ia=%-6u et=%-5u ct=%-10u hct=%-5u hpe=%-3u hpv=%-3u dct=%-3u doa=%-3u cadc=%-4u cavg=%-4u, 1=%-4u 2=%-4u 3=%-4u 4=%-4u  5=%-4u  6=%-4u\r\n",
            debug_values_copy[0], debug_values_copy[1],debug_values_copy[2],
            debug_values_copy[3], debug_values_copy[4] , debug_values_copy[5],
            debug_values_copy[6], debug_values_copy[7], debug_values_copy[8],
            debug_values_copy[9], debug_values_copy[10] ,debug_values_copy[11] , debug_values_copy[13] , current_adc, current_average,
            hall_pattern_intervals[1],hall_pattern_intervals[2],hall_pattern_intervals[3],
            hall_pattern_intervals[4],hall_pattern_intervals[5],hall_pattern_intervals[6] );
        */    
        // %[flags][FieldWidth][.Precision]ConversionSpecifier%
        // c	one char , d signed integer, u unsigned integer , x	hexadecimal integer , s	string , p  pointer?  8-digit hexadecimal integer. (Argument shall be a pointer to void.)
        printf("in irq0=%uus irq1=%uus irq1b=%uus irq1c=%uus irq1d=%uus irq1e=%uus\r\n", 
            debug_time_ccu8_irq0 << 2,debug_time_ccu8_irq1 << 2,debug_time_ccu8_irq1b << 2,
            debug_time_ccu8_irq1c << 2,debug_time_ccu8_irq1d << 2,debug_time_ccu8_irq1e << 2);
        debug_time_ccu8_irq0 = 0;
        debug_time_ccu8_irq1 = 0;
        debug_time_ccu8_irq1b = 0;
        debug_time_ccu8_irq1c = 0;
        debug_time_ccu8_irq1d = 0;
        debug_time_ccu8_irq1e = 0;
        #ifdef XMC_ASSERT_ENABLE
        printf("XMC_ASSERT_ENABLE\n\r");
        #endif
    }
}

uint32_t first_debug_values[100][20];
uint32_t first_debug_index = 0; 
#define LINES 98
void print_hall_pattern_debug2(){
    
    if (first_debug_index == LINES){
        printf("Now since pattern angle delay d_c_t d_c cur_t curr      error valid com_t rot_ticks ofa refV\r\n");
        for (uint32_t i = 0; i<LINES; i++){
            for (uint32_t j = 0; j<15; j++){
                printf("%u ", first_debug_values[i][j]);
                if (j == 8) {    // put a space before the error counter
                    printf("    ");
                }
            }
            printf("\r\n");
        }
    }
}

/* [] END OF FILE */
