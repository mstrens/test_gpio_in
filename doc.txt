***********  use of posif ******************

- when a change occurs on hall sensor, posif.out sent a signal to ccu4 slice 0 Input0
- this rising edge activates the function clear & start timer
- when ccu4 timer reaches compare register, ccu4 ST changes (go high)
- this changes is received by posif on dsel 
- rising edge of dsel on posif generates a sample of hall pins
- if the sample == current , nothing happens
- if sample == expected,
    - in posif : shadow registers (current and expected patterns) are copied in active registers
    - in posif: shadow registers becomes 0 0 (and must be reloaded)
    - in posif a service request 0 is generated; it can be handled by POSIT0_1_IRQ to upload new value in shadow reg
     (in fact, this could also be done by the interrupt generated by ccu4 slice 1 on compare match)
    - in posif : posif set OUT1 high and this signal is connected to CCU4 slice 1 input 0
    - in CCU4 slice 1 = this input signal activates an envent 0 that generates
            - a function "capture" of the current value of the timer (this value can be read to know the interval)
            - a clear & start of the timer
            - a service request 0 that can be used e.g. in an interrupt CCU4_0_0_IRQ to get the capured value
                note: reading the value, reset a flag ; this allows to know if it is a new value or nothing
        note: when timer count up to 0XFFFF but it can be changed (with prescaler = 256, 1 tick = 4 usec, so max = 65536 *4 = 0,262 sec)
        with 6 phases per electrical rotation and 4 poles, this is equivalent to a rps of 0,15 = about 10 rpm
        This could generate an CCU4 SR1 but it is not yet done because at power with 15° per 0,5 sec the limit is reached.
- if sample is not the expected, it is possible just to discard or to stop some process. Anyway OUT3 is set
    if IDLE is activated in the setup, a wrong pattern can generate an OU2 that can be used to stop the PWM
    currently in case of wrong pattern, there are no action generated by POSIF
notes : when slice 1 count up to the end of the period, ccu4 generates a service request 1 to say that motor is running slow
This SR1 could be manage to stop the motor state by an ISR


-------- use of vadc and ccu8
ccu8 slice 0,1,2 are used to generate PWM . 
They are configure as center align, with prescaler = 1 (to get 64Mz ; this is 4* the freq of TSDZ2)
Period is 1680 (4*420) (so one cycle is 3360 clocks and so one tick every 15,625 nsec, => 19Khz => 26us per cycle)
CC8 slice 3 is used to generate 2 IRQ : one when counting up at 840 (4*210) (SR0), and the other (SR1) at 840 counting down
CC8 slice 3 generates also a SR3 at period match; this is connected to VADC group 0 to trigger the queue and so measure total current (pin 2.8)
The same pin (2.8) is also measured at one match counting donw because CCU8 slice 2 trigger a SR2 that is connected to VADC group 1 queue.
NOte:  the connection of SR2 can't be done within device manager because this tool accept only one connection between CCU8 and VADC
So set up of this connection is done in main.c

Currently, only pin 2.8 (total current) is measured in the 2 queues. The other are measured in background because not time critical.
I do not know if it is right to measure total current at period match and one match because all 3 mosfets are ON (on low side in one case and high side in the other one).
It should probably be OK if there is some hardware filter. To be tested.

In device configurator, it is possible to setup a channel event (per channel) when the ADC value is e.g. out of limits.
Still, it seems that it is not possible to let the channel event generates a service request.
It is then required to use 
VADC_GROUP_ChannelSetEventInterruptNode	(	XMC_VADC_GROUP_t *const 	group_ptr,
const uint32_t 	ch_num,
const XMC_VADC_SR_t 	sr 
)
And also it is required to add the 2 lines of code for NIVC to get the interrupt
Note:  per group only SR0 and SR1 can be connected to NIVC (17,18 for group 0 and 19,20 for group 1)

 

---------------  set up of hall offset ------------------------
It seems that hall sensors are not perfectly alligned and not eaqualy separated by 120°
To find best solution, I tried the following:


- 1 activate a #define in main.h in order to let the program automatically increases "calibrated_offset_angle" by step of 1 (360°/256) 
#define CALIBRATE_HALL_SENSORS (1)

This has several impacts:
calibrated_offset_angle is a value added to the absolute angle (deducted from the hall pattern) to get the index to read the svm table
calibrated_offset_angle starts from e.g. 15 (it is defined in motor.c) and will be increased by 1 every 4 sec
This #define also force CALIBRATED_HALL_ANGLE_PATTERN_1 ... 6 to be discarded during the calibration
It set also PWM_DUTY_CYCLE_MAX = 40 (instead of 255) in main.h (to reduce the max duty cycle and so the ui16_adc_voltage)
      This reduce the speed and so the impact of the delay for the hall sensor to change from one state to another one (rising of failing time)

- flash the program with those changes

- connect a ftdi on UART TX to get the calibration messages (9600 baud 8 bits no parity)

- let the motor runs with a 36V battery (and low ramp values = default) with no load

- look at the calibration messages: each lines gives 
    - the current value for calibrated_offset_angle,
    - the average ADC current (based on 2 captures at 19 kHz)
    - enlapsed times between 2 hall pattern changes. Sequence is 1, 3, 2, 6, 4, 5.
        The enlapse time under i is the number of ticks when pattern becomes i; so 1 is between 5 and 1, under 2 between 3 and 2, ....
        Note : 1 tick = 4 usec (250000Hz)
    There will be several message lines for each calibrated_offset_angle

!! Take care that the current can become very high. So while the program is running, check the average current and stop the program when the average current starts to increase afte some decrease.

- look at the value of calibrated_offset_angle giving the lowest average current and select this value minus 1 (because average current is calculated when it uses the next debug_offset_value)

- write down the 6 enlapsed times. They will not be equal. Calculates sum of the 6 values, the average and the differences between average and each of the values.
Those difference gives the errors in hall sensor position.
We have to convert them in angle. Each angle error is the difference / sum * 256 / 360. (note 256 is equivalent to 360° in the firmware).
Then we take one hall pattern as reference  (eg. pattern 5 = 30°) and we calculate the angles using the error in a cumulative way.
We calculate then the absolute error compared to the theoretical position.
This is done in an xls (in google drive) "TSZD8 Hall offset calibration"
Change the #define CALIBRATED_HALL_ANGLE_PATTERN_1...6 with the values that have been calculated.

- If you run the firmware again, you should normally get a lower value for the average current.




